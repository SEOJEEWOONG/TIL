# 알고리즘

> 작성 날짜 : 2021-12-01

* 시간복잡도 : 문제를 해결하는데 걸리는 시간
* 안정 정렬 : 정렬 이후에 같은 키 값에 대해 정렬 순서가 유지되는 것을 보장
* 불안정 정렬 : 정렬 이후에 같은 키 값에 대해 정렬 순서가 유지되지 않는다.

**Sort**

* Bubble Sort : 인접한 두 원소의 대소를 비교하고, 조건이 맞지 않다면 자리를 교환하며 정렬하는 알고리즘
    - 장점 : 구현이 간단하고, 소스코드가 직관적이다.
    - 단점 : 시간복잡도 O(N^2)

* Selection Sort : 해당 순서에 원소를 넣을 위치는 이미 정해져 있고 어떤 원소를 넣을지 선택하는 알고리즘
    - 해당 자리를 선택하고 그 자리에 오는 값을 찾는 것
    - 과정
        - 주어진 배열 중에 최솟값을 찾는다.
        - 그 값을 맨 앞에 위치한 값과 교체한다.
        - 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.
    - 장점
        - 구현이 간단하고, 소스코드가 직관적이다.
        - 다른 메모리 공간이 필요없다.
    - 단점
        - 시간 복잡도가 O(N^2)
        - 불안정 정렬

* Insertion Sort : 2번째 원소부터 시작하여 그 앞의 원소들과 비교하여 삽입할 위치를 지정한 후 원소를 뒤로 옮기고 지정된 자리에 자료 삽입
    - 이미 정렬되어 잇는 최선의 경우 왼쪽에 있는 1개만 비교하면 되니까 O(N)
    - 최악의 경우 O(N^2), 평균 O(N^2)
    - 안정 정렬

* Quick Sort : Devide and Conquer 방법을 통해 주어진 배열 정렬
    - 정렬 과정
        1) 배열 가운데서 pivot으로 활용할 원소를 고른다.
        2) pivot 앞에는 pivot보다 작은 값, pivot 뒤에는 pivot보다 큰 값 : Divide
        3) 분할된 두 개의 작은 배열에 대해 재귀적으로 반복 : Conquer
    - 최악 O(N^2) => 오름차순 정렬인데 이미 내림차순 정렬일 경우, 최선 및 평균 O(NlogN)

* Merge Sort : 영역을 쪼갤 수 있을 만큼 쪼개고(mergesort), 정렬(merge)

* Heap Sort : 가장 크거나 가장 작은 값을 구해야 할 때

* Binary Search : 정렬되어 잇는 리스트에 대해 탐색 범위를 두 부분으로 분할하면서 찾는 방식

* Hash : 데이터를 효율적으로 관리하기 위해 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 것
    - BFS로 완전 탐색하는 문제에 Hash 적용
    - key에 해당하는 배열에서만 확인하게끔 코딩 진행
    - Hash function을 통해 key 값을 계산하고, 배열의 key 인덱스에 데이터 저장
        - Chaining : 연결리스트
            - 장점 : 삽입 및 삭제가 용이, Hash Table에 저장되어 있는 양이 증가해도 성능 감소가 선형적으로 증가
            - 단점 : 데이터의 크기가 작을 경우 chaining에 필요한 포인터 배열의 Overhead 존재
        - Open Addressing : 배열로 해결
            - Linear Probing : 일반적인 인덱스 저장 방식 -> clustering 문제
            - Quadratic probing : 제곱을 더해서 저장 -> clustering 문제는 해결
            - Double Hashing probing : 1차 해시 함수에서 충돌되면 2차 해시 함수로 계산해서 인덱스 추가

* DFS
    - 루트 노드 또는 임의 노드에서 다음 브랜치로 넘어가기 전에 해당 브랜치 탐색 => stack 및 재귀함수로 호출
    - 모든 경로를 방문해야할 때 적합

* BFS
    - 루트 노드 또는 임의 노드에서 인접한 노드부터 탐색
    - 큐를 통해 구현하고 최소 비용 찾을 때 적합

* DP
    - 커다란 문제를 쉽게 해결하기 위해 작게 쪼개서 해결하는 방법
    - 작은 문제에서 반복이 일어나고 같은 문제는 항상 정답이 같다
    - Memoization : 한번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식

* Bitmask : 배열의 요소를 이진수로 표현

* Trie
    - 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료 구조
    - DFS 형태로 검색

* B Tree
    - 자식을 2개 밖에 못가지는 기존 트리의 한계 극복
    - 모든 리프노드 들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리
    - M차 B-Tree
        - 노드는 (M/2)(반올림)~M개 의 자식을 가질 수 있다.
        - 노드의 키 개수 = 노드 자식수 - 1
        - 최소 차수 : 자식의 하한 수
            - M = 최소차수 * 2 - 1
            - 키의 최소 개수는 최소차수 - 1
        - 노드 = 키 + 자식노드를 가리키는 포인터
        - key들은 노드 안에서 항상 정렬된 값
        - 이진 검색 트리처럼 key들의 왼쪽 값은 항상 key값보다 작고, key의 오른쪽 값은 key값보다 크다
        - key 검색 과정 : 검색하고자 하는 key = k
            1) 루트 노드에서 시작하여 key들을 순회하면서 검사한다.
                1-1) 만일 k와 같은 key를 찾았다면 검색을 종료한다.
                1-2) 검색하는 값과 key들의 대소 관계를 비교한다
                1-3) 어떤한 key들 사이에 k가 들어가면 key들 사이의 자식노드로 내려간다.
            2) 해당 과정을 리프노드에 도달할 때 까지 반복한다
                2-1) 만일 리프노드에도 k와 같은 key가 없다면 검색 실패
        - key 삽입 과정
            - 요소 삽입에 적절한 리프노드를 검색
            - 필요한 경우 노드를 분할해야 한다
            1) 트리가 비어 있다면 루트 노드를 할당하고 k를 삽입
            2) 루트노드가 가득 찼다면 노드를 분할하고 리프노드가 생성된다.
            3) 이후부터는 삽입하기에 적절한 리프노드를 찾아 k를 삽입한다.
                - 분할이 일어나지 않는 경우
                    3-1) 리프 노드가 가득차지 않았다면 오름차순으로 k를 삽입
                - 분할이 일어나는 경우
                    3-1) 오름차순으로 요소를 삽입한다
                    3-2) 노드가 담을 수 있는 최대 key 개수를 초과
                    3-3) 중앙값에서 분할을 수행한다.
                    3-4) 중앙값은 부모 노드로 병합하거나 새로 생성된다.
                    3-5) 왼쪽키들은 왼쪽 자식으로 오른쪽 키는 오른쪽 자식으로 분할된다
                    3-6) 부모노드를 검사해서 또 다시 가득 찼다면 다시 부모노드에서 위 과정을 반복한다.
        - key 삭제 과정
            - 요소를 삭제하기 위해서 삭제할 키가 있는 노드 검색, 키 삭제, 필요한 경우 트리 균형 조정
            - inorder predecessor : 노드의 왼쪽 자손에서 가장 큰 key
            - inorder successor : 노드의 오른쪽 자손에서 가장 작은 key
            - 부모 키 : 부모노드의 key들 중 왼쪽 자식으로 본인 노드를 가지고 있는 key값, 마지막 자식 노드의 경우 부모의 마지막 key
            - Case 1 : 삭제할 key가 리프 노드에 있는 경우
                - Case 1.1 : 현재 노드의 key 개수가 최소 key개수보다 클 경우
                    1) 다른 노드들의 영향 없이 k 단순 삭제
                - 현재 노드의 key 개수 = 최소 key 개수
                    - Case 1.2 : 왼쪽 또는 오른쪽 형제 노드의 key가 최소 key개수보다 클 경우
                        1) 부모 key 값으로 k를 대체
                        2) 최소 key 개수 이상의 키를 가진 형제 노드가 왼쪽 형제라면 가장 큰 값을, 오른쪽 형제라면 가장 작은 값을 부모 key로 대체한다.
                    - Case 1.3 : 왼쪽과 오른쪽 형제 노드의 key가 최소 key 개수이고, 부모 노드의 key가 최소개수보다 클 경우
                        1) k를 삭제한 후 부모 key를 형제 노드와 병합
                        2) 부모 노드의 key개수를 하나 줄이고, 자식 수 역시 하나 줄여 B-Tree 유지
                    - Case 1.4 : 자신과 형제, 부모 노드의 key 개수가 모두 최소 key개수
                        - 부모노드를 루트 노드로 한 부분 트리의 높이가 줄어드는 경우 -> 재구조화
            - Case 2 : 삭제할 key k가 내부 노드에 있고, 노드나 자식에 key가 최소 key수보다 많을 경우
                1) 현재 노드의 inorder predecessor 또는 inorder successor와 k의 자리를 바꾼다.
                2) Case 1로 회귀
            - Case 3: 삭제할 key k가 내부 노드에 있고, 노드에 key 개수가 최소 key 개수만큼, 노드의 자식 key 개수도 모두 최소 key 개수인 경우 : 재구조화
                1) k를 삭제하고 k의 양쪽 자식을 병합하여 하나의 노드로 만든다.
                2) k의 부모 key를 인접한 형제 노드에 붙인다
                3) 병합한 노드를 자식노드로 설정
                - Case 3.1 : 새로 구성된 인접 형제 노드의 key가 최대 key수를 넘는 경우
                    4) 삽입할 때 노드 분할 과정 수행
                - Case 3.2 : 원래 k의 부모 노드가 최소 key수보다 작을 경우
                    4) k의 부모 노드의 부모 노드를 k의 부모 노드의 인접한 형제 노드에 붙인다.
                    5) k의 병합한 양쪽 자식을 자식노드로 설정

* B+ Tree : 리프 노드는 연결리스트의 형태를 띄어 선형 검색이 가능하다.
    - 실제 DB의 인덱싱은 B+ 트리로 이루어져있다.
        - 인덱싱은 어떤 자료를 찾는 데 key 값을 이용해 효과적으로 찾는 기능
    - 모든 key, data가 리프 노드에 모여있다.
        - B Tree는 각 노드마다 key data를 가진다.
    - 모든 리프노드가 연결리스트의 형태를 띈다.
    - 리프노드의 부모 key는 리프노드의 마지막 key보다 작거나 같다.
    - 노드는 (M/2) ~ M개의 자식 가질 수 있다.
    - 노드는 (M/2)-1 ~ M-1개의 키 가질 수 있다.
    - M = 최소차수(최소 자식수) * 2 - 1
    - 삽입 과정
        - Case 1.1 : 분할이 일어나지 않고 삽입 위치가 리프노드의 가장 앞 key자리가 아닐 경우
            1) B-Tree와 동일하게 수행
        - Case 1.2 : 분할이 일어나지 않고 삽입 위치가 리프노드의 가장 앞 key자리인 경우
            1) 삽입 후 부모 key를 삽입된 key로 갱신하고 data를 넣어준다.
        - Case 1.3 : 분할이 일어나는 삽입 과정
            Case 1.3.1 : 분할이 일어나는 노드가 리프노드가 아니다.
                1) 기존 B Tree와 동일하게 분할
            Case 1.3.2 : 분할이 일어나는 노드가 리프노드이다.
                1) 중간 key를 부모 key로 올리지만 오른쪽 노드에 중간 key를 포함하여 분할한다.
                    - 왼쪽 자식노드와 오른쪽 자식노드를 이어줘 연결리스트 형태 유지
    - 삭제 과정
        - Case 1.1 : 삭제할 key k가 index에 없고 리프노드의 가장 처음 key가 k가 아닌 경우
            1) 기존 B Tree와 동일
        - Case 1.2 : 삭제할 key k가 리프노드의 가장 처음 key인 경우
            - 항상 k 가 인덱스 내에 존재해야 한다.
            - Case 1.2.1 : 리프노드가 최소 key의 개수
                1) 삭제할 리프노드의 부모노드 삭제
                2) 리프노드와 형제 노드 병합
                3) 삭제한 리프노드의 부모노드의 형제노드와 붙인다
                4) 리프노드 삭제하고 부모노드의 리프노드 값 리프노드 형제값으로 변경
    - 참고 : https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree